# -*- mode: ruby -*-
# vi: set ft=ruby :
require 'yaml'
require './lib/gen_node_infos'
require './lib/predicates'

def is_plugin(name)
  if Vagrant.has_plugin?(name)
    puts "using #{name}"
  else
    puts "please run vagrant plugin install #{name}"
    exit(1)
  end
end

base_dir = File.expand_path(File.dirname(__FILE__))
conf = YAML.load_file(File.join(base_dir, "cluster.yml"))
ninfos = gen_node_infos(conf)
tld="wd"

## vagrant plugins required:
# vagrant-aws, vagrant-berkshelf, vagrant-omnibus, vagrant-hosts, vagrant-cachier
Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/trusty64"

  # enable plugins
  config.berkshelf.enabled = true
  config.berkshelf.berksfile_path ="./Berksfile"
  config.omnibus.chef_version = :latest

  # if you want to use vagrant-cachier,
  # please install vagrant-cachier plugin.
  if Vagrant.has_plugin?("vagrant-cachier")
    config.cache.enable :apt
    config.cache.enable :chef
  end

  is_plugin("vagrant-berkshelf")
  is_plugin("vagrant-omnibus")
  is_plugin("vagrant-hosts")

  # define VMs. all VMs have identical configuration.
  [ninfos[:zk], ninfos[:master], ninfos[:slave]].flatten.each_with_index do |ninfo, i|
    config.vm.define ninfo[:hostname] do |cfg|

      cfg.vm.provider :virtualbox do |vb, override|
        # https://github.com/BerlinVagrant/vagrant-dns
        override.dns.tld = tld
        override.vm.hostname = ninfo[:hostname]
        override.vm.network :private_network, :ip => ninfo[:ip]
        override.vm.provision :hosts

        # https://docs.vagrantup.com/v2/virtualbox/configuration.html
        # Does 'name' do anything without a gui?
        vb.name = 'vagrant-mesos-' + ninfo[:hostname]
        vb.customize ["modifyvm", :id, "--memory", ninfo[:mem], "--cpus", ninfo[:cpus] ]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/root root"
        end

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/vagrant vagrant"
        end
      end

      cfg.vm.provider :aws do |aws, override|
        aws.access_key_id = conf["access_key_id"]
        aws.secret_access_key = conf["secret_access_key"]

        aws.region = conf["region"]
        if conf["custom_ami"] then
            override.vm.box = "dummy"
            override.vm.box_url = "https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box"
            aws.ami = conf["custom_ami"]
        end

        # workaround for https://github.com/mitchellh/vagrant-aws/issues/275
        aws.ami=""

        aws.instance_type = ninfo[:instance_type]
        aws.keypair_name = conf["keypair_name"]
        aws.subnet_id = conf["subnet_id"]
        aws.security_groups = conf["security_groups"]
        aws.private_ip_address = ninfo[:ip]
        aws.tags = {
          Name: "vagrant-mesos-#{ninfo[:hostname]}"
        }
        if !conf["default_vpc"] then
          aws.associate_public_ip = true
        end

        override.ssh.username = "ubuntu"
        override.ssh.private_key_path = conf["ssh_private_key_path"]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/ubuntu ubuntu"
        end

        if master?(ninfo[:hostname]) || slave?(ninfo[:hostname]) then
          override.vm.provision :shell , :inline => <<-SCRIPT
            PUBLIC_DNS=`wget -q -O - http://169.254.169.254/latest/meta-data/public-hostname`
            hostname $PUBLIC_DNS
            echo $PUBLIC_DNS > /etc/hostname
            HOSTNAME=$PUBLIC_DNS  # Fix the bash built-in hostname variable too
            SCRIPT
        end

        if master?(ninfo[:hostname]) then
          override.vm.provision :shell , :inline => 'restart mesos-master'
        end

        if slave?(ninfo[:hostname]) then
          override.vm.provision :shell , :inline => 'restart mesos-slave'
        end
      end

      # mesos-master doesn't create its work_dir.
      master_work_dir = "/var/run/mesos"
      if master?(ninfo[:hostname]) then
        cfg.vm.provision :shell, :inline => "mkdir -p #{master_work_dir}"
      end

      cfg.vm.provision :chef_solo do |chef|
#       chef.log_level = :debug
        chef.add_recipe "apt"

        if master?(ninfo[:hostname]) then
          chef.add_recipe "mesos::master"
          chef.json  = {
            :mesos=> {
              :type         => "mesosphere",
              :version      => conf["mesos_version"],
              :mesosphere   => {
                :build_version    => conf["mesos_build_version"]
              },
              :master_ips   => ninfos[:master].map { |m| "#{m[:ip]}" },
              :slave_ips    => ninfos[:slave].map { |s| "#{s[:ip]}" },
              :master       => if ninfos[:zk].length > 0 then
                {
                  :cluster => "MyCluster",
                  :quorum => "#{(ninfos[:master].length.to_f/2).ceil}",
                  :work_dir => master_work_dir,
                  :zk => "zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(", ")+"/mesos",
                  :ip => "#{ninfo[:ip]}"
                }
              else
                {
                  :cluster => "MyCluster",
                  :quorum => "#{(ninfos[:master].length.to_f/2).ceil}",
                  :work_dir => master_work_dir,
                  :ip => "#{ninfo[:ip]}"
                }
              end
            }
          }
        elsif slave?(ninfo[:hostname]) then
          chef.add_recipe "java"
          chef.add_recipe "mesos::slave"
          chef.json = {
            :java => {
              :jdk_version  => "7"
            },
            :mesos => {
              :type         => "mesosphere",
              :version      => conf["mesos_version"],
              :mesosphere   => {
                :build_version    => conf["mesos_build_version"]
              },
              :slave        => {
                :master       => if ninfos[:zk].length > 0 then
                                   "zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(", ")+"/mesos"
                                 else
                                   "#{ninfos[:master][0][:ip]}:5050"
                                 end,
                :ip           => "#{ninfo[:ip]}",
                :containerizers => "mesos",
                :isolation => "cgroups/cpu,cgroups/mem",
                :executor_registration_timeout => "5mins",
                :hostname => "#{ninfo[:hostname]}.#{tld}"
              }
            }
          }
        elsif zk?(ninfo[:hostname]) then
          chef.add_recipe "apache_zookeeper"
        end
      end

      if zk?(ninfo[:hostname]) then
        myid = (/zk([0-9]+)/.match ninfo[:hostname])[1]
        cfg.vm.provision :shell, :inline => <<-SCRIPT
          sudo service zookeeper stop
          sudo mkdir -p /tmp/zookeeper
          sudo chmod 755 /tmp/zookeeper
          sudo chown zookeeper /tmp/zookeeper
          sudo -u zookeeper echo #{myid} > /tmp/zookeeper/myid
          sudo -u zookeeper /opt/chef/embedded/bin/ruby /vagrant/scripts/gen_zoo_conf.rb > /opt/zookeeper/conf/zoo.cfg
          sudo service zookeeper start
        SCRIPT
      end

    end
  end

  if conf["marathon_enable"] then
    config.vm.define :marathon do |cfg|
      marathon_ip = conf["marathon_ipbase"]+"11"

      cfg.vm.provider :virtualbox do |vb, override|
        override.dns.tld = tld
        override.vm.hostname = "marathon"
        override.vm.network :private_network, :ip => marathon_ip
        override.vm.provision :hosts

        vb.name = 'vagrant-mesos-' + "marathon"
        vb.customize ["modifyvm", :id, "--memory", conf["marathon_mem"], "--cpus", conf["marathon_cpus"] ]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/root root"
        end

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/vagrant vagrant"
        end
      end

      cfg.vm.provider :aws do |aws, override|
        aws.access_key_id = conf["access_key_id"]
        aws.secret_access_key = conf["secret_access_key"]

        aws.region = conf["region"]
        if conf["custom_ami"] then
          override.vm.box = "dummy"
          override.vm.box_url = "https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box"
          aws.ami = conf["custom_ami"]
        end

        # workaround for https://github.com/mitchellh/vagrant-aws/issues/275
        aws.ami=""

        aws.instance_type = conf["marathon_instance_type"]
        aws.keypair_name = conf["keypair_name"]
        aws.subnet_id = conf["subnet_id"]
        aws.security_groups = conf["security_groups"]
        aws.private_ip_address = marathon_ip
        aws.tags = {
          Name: "vagrant-mesos-marathon"
        }
        if !conf["default_vpc"] then
          aws.associate_public_ip = true
        end

        override.ssh.username = "ubuntu"
        override.ssh.private_key_path = conf["ssh_private_key_path"]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/ubuntu ubuntu"
        end

        override.vm.provision :shell , :inline => <<-SCRIPT
          PUBLIC_DNS=`wget -q -O - http://169.254.169.254/latest/meta-data/public-hostname`
          hostname $PUBLIC_DNS
          echo $PUBLIC_DNS > /etc/hostname
          HOSTNAME=$PUBLIC_DNS  # Fix the bash built-in hostname variable too
          SCRIPT
      end

      cfg.vm.provision :chef_solo do |chef|
        chef.add_recipe "apt"
        chef.add_recipe "curl"
        chef.add_recipe "zip"
        chef.add_recipe "mesos"
        chef.add_recipe "java"
        chef.add_recipe "sbt-extras"
        chef.add_recipe "scala"
        chef.json = {
          :java => {
            :install_flavor => "oracle",
            :jdk_version => "8",
            :ark_timeout => 1800,
            :oracle => {
              :accept_oracle_download_terms => "true"
            },
            :jdk => {
              "8" => {
                :x86_64 => {
                  :url => "file:///vagrant/jdk-8u65-linux-x64.tar.gz",
                  :checksum => "88db2aacdc222c2add4d92822f528b7a2101552272db4487f33b38b0b47826e7"
                }
              }
            }
          },
          :mesos => {
            :type         => "mesosphere",
            :version      => conf["mesos_version"],
            :mesosphere   => {
              :build_version    => conf["mesos_build_version"]
            }
          }
        }
      end

      cfg.vm.provision :shell, :privileged => true, :inline => <<-SCRIPT
        if ! grep -q LIBPROCESS_IP ~/.bashrc; then
          echo "export LIBPROCESS_IP=#{marathon_ip}" >> ~/.bashrc
          . ~/.bashrc
        fi
        mkdir -p /var/log/marathon
        RUNNING_MARATHON=`ps augwx | grep marathon | grep -v grep | tr -s " " | cut -d' ' -f2`
        if [ $RUNNING_MARATHON ]; then kill -9 $RUNNING_MARATHON; fi
        if ! [[ -f /etc/init.d/marathon || -f /opt/marathon/target/scala-2.11/marathon-assembly-0.12.0-RC1.jar ]]; then
          if [ ! -f /opt/marathon/target/scala-2.11/marathon-assembly-0.12.0-RC1.jar ]; then
            # This logic is not totally safe here but close enough
            if [ ! -d /opt/marathon ]; then
              mkdir -p /opt
              cd /opt
              if [ -d /vagrant/marathon ]; then
                ln -s /vagrant/marathon marathon
              else
                curl -o marathon.zip -L https://github.com/mesosphere/marathon/archive/v0.12.0-RC1.zip
                unzip marathon.zip
                rm marathon.zip
                mv marathon* marathon
                cd /opt/marathon
                mkdir -p /root/.sbt/launchers/0.13.8
                curl -L -o /root/.sbt/launchers/0.13.8/sbt-launch.jar http://dl.bintray.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.13.8/sbt-launch.jar
                sbt update
                sbt assembly
              fi
            fi
          fi
          rm /etc/init.d/marathon
          update-rc.d marathon remove
          cat <<-STARTUP > /etc/init.d/marathon
#! /bin/sh
### BEGIN INIT INFO
# Provides:         Marathon
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Marathon service runner
# Description:       Marathon service runner
### END INIT INFO

            #
            # Process finder
            #
            marathon_p()
            {
                echo \\\`ps -ef | grep marathon | grep java | awk '{ print \\$2}'\\\`
            }

            #
            # Function that starts the daemon/service
            #
            do_start()
            {
                # Return
                #   0 if daemon has been started
                if [ "\\$(marathon_p)" ]; then return 1; fi
                LIBPROCESS_IP=#{marathon_ip} nohup /opt/marathon/bin/start --master \
#{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/mesos"} --zk \
#{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/marathon"} \
--event_subscriber http_callback --hostname marathon.#{tld} > \
/var/log/marathon/nohup.log 2> /var/log/marathon/nohup.log < /dev/null &
                return 0
            }

            #
            # Function that stops the daemon/service
            #
            do_stop()
            {
                # Return
                #   0 if daemon has been stopped
                #   1 if daemon was already stopped
                if [ ! "\\$(marathon_p)" ]; then return 1; fi

                kill -KILL \\$(marathon_p)
                return 0;
            }

            case "\\$1" in
              start)
                do_start
                ;;
              stop)
                do_stop
                ;;
              restart|force-reload)
                do_stop
                do_start
                ;;
            esac
STARTUP
          chmod 755 /etc/init.d/marathon
        fi
        chmod +x /etc/init.d/marathon
        update-rc.d marathon defaults
#        echo "LIBPROCESS_IP=#{marathon_ip} nohup /opt/marathon/bin/start --master "#{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/mesos"}" --zk "#{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/marathon"}" --event_subscriber http_callback --hostname marathon.#{tld}"
        service marathon restart
        SCRIPT

      if conf["chronos_enable"] then
        cfg.vm.provision :shell, :privileged => true, :inline => <<-SCRIPT
          # Install and run Chronos based on:
          # https://mesosphere.io/learn/run-chronos-on-mesos/
          mkdir -p /var/log/chronos
          LIBPROCESS_IP=#{marathon_ip} nohup /opt/chronos/bin/start-chronos.bash --master #{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/mesos"} --zk_hosts #{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/mesos"} --http_port 8081 > /var/log/chronos/nohup.log 2> /var/log/chronos/nohup.log < /dev/null &
          SCRIPT
      end

    end
  end

end
